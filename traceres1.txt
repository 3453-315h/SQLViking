==FIRST FIND_RES CALL==
 --- modulename: tds, funcname: find_result_or_done
tds.py(3825):         self.done_flags = 0
tds.py(3826):         while True:
tds.py(3827):             marker = self.get_token_id()
 --- modulename: tds, funcname: get_token_id
tds.py(3770):         self.set_state(TDS_READING)
 --- modulename: tds, funcname: set_state
tds.py(3088):         prior_state = self.state
tds.py(3089):         if state == prior_state:
tds.py(3091):         if state == TDS_PENDING:
tds.py(3097):         elif state == TDS_READING:
tds.py(3103):             self.state = state
tds.py(3124):         return self.state
tds.py(3771):         try:
tds.py(3772):             marker = self._reader.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(736):             if self._have >= self._size:
tds.py(737):                 self._read_packet()
 --- modulename: tds, funcname: _read_packet
tds.py(841):         try:
tds.py(842):             header = readall(self._transport, _header.size)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(3977):         buf = self.receive(size)
 --- modulename: tds, funcname: receive
tds.py(3969):         if size is None:
tds.py(3972):             val = self.data[self.curs:self.curs+size]
tds.py(3973):             self.curs += size
tds.py(3974):         return val
tds.py(3978):         if len(buf) == 0:
tds.py(3981):         return buf
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(846):         self._pos = 0
tds.py(847):         self._type, self._status, self._size, self._session._spid, _ = _header.unpack(header)
tds.py(848):         self._have = _header.size
tds.py(849):         assert self._size > self._have, 'Empty packet doesn make any sense'
tds.py(850):         self._buf = self._transport.read(self._size - self._have)
 --- modulename: tds, funcname: read
tds.py(3977):         buf = self.receive(size)
 --- modulename: tds, funcname: receive
tds.py(3969):         if size is None:
tds.py(3972):             val = self.data[self.curs:self.curs+size]
tds.py(3973):             self.curs += size
tds.py(3974):         return val
tds.py(3978):         if len(buf) == 0:
tds.py(3981):         return buf
tds.py(851):         self._have += len(self._buf)
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(3779):         return marker
tds.py(3828):             if marker == TDS7_RESULT_TOKEN:
tds.py(3831):             elif marker in (TDS_DONE_TOKEN, TDS_DONEPROC_TOKEN, TDS_DONEINPROC_TOKEN):
tds.py(3838):                 self.process_token(marker)
 --- modulename: tds, funcname: process_token
tds.py(3764):         handler = _token_map.get(marker)
tds.py(3765):         if not handler:
tds.py(3767):         return handler(self)
 --- modulename: tds, funcname: process_env_chg
tds.py(2973):         r = self._reader
tds.py(2974):         size = r.get_smallint()
 --- modulename: tds, funcname: get_smallint
tds.py(761):         return self.unpack(_smallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2975):         type = r.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2977):         if type == TDS_ENV_SQLCOLLATION:
tds.py(2987):         elif type == TDS_ENV_BEGINTRANS:
tds.py(2992):         elif type == TDS_ENV_COMMITTRANS or type == TDS_ENV_ROLLBACKTRANS:
tds.py(2996):         elif type == TDS_ENV_PACKSIZE:
tds.py(3008):         elif type == TDS_ENV_DATABASE:
tds.py(3012):         elif type == TDS_ENV_LANG:
tds.py(3016):         elif type == TDS_ENV_CHARSET:
tds.py(3024):         elif type == TDS_ENV_DB_MIRRORING_PARTNER:
tds.py(3027):         elif type == TDS_ENV_LCID:
tds.py(3034):             skipall(r, size - 1)
 --- modulename: tds, funcname: skipall
tds.py(625):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(626):     if len(res) == size:
tds.py(627):         return
tds.py(3826):         while True:
tds.py(3827):             marker = self.get_token_id()
 --- modulename: tds, funcname: get_token_id
tds.py(3770):         self.set_state(TDS_READING)
 --- modulename: tds, funcname: set_state
tds.py(3088):         prior_state = self.state
tds.py(3089):         if state == prior_state:
tds.py(3090):             return state
tds.py(3771):         try:
tds.py(3772):             marker = self._reader.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(3779):         return marker
tds.py(3828):             if marker == TDS7_RESULT_TOKEN:
tds.py(3829):                 self.process_token(marker)
 --- modulename: tds, funcname: process_token
tds.py(3764):         handler = _token_map.get(marker)
tds.py(3765):         if not handler:
tds.py(3767):         return handler(self)
 --- modulename: tds, funcname: <lambda>
tds.py(3876):     TDS7_RESULT_TOKEN: lambda self: self.tds7_process_result(),
 --- modulename: tds, funcname: tds7_process_result
tds.py(2730):         r = self._reader
tds.py(2735):         num_cols = r.get_smallint()
 --- modulename: tds, funcname: get_smallint
tds.py(761):         return self.unpack(_smallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2739):         if num_cols == -1:
tds.py(2743):         self.param_info = None
tds.py(2744):         self.has_status = False
tds.py(2745):         self.ret_status = False
tds.py(2746):         self.rows_affected = TDS_NO_COUNT
tds.py(2747):         self.more_rows = True
tds.py(2748):         self.row = [None] * num_cols
tds.py(2749):         self.res_info = info = _Results()
 --- modulename: tds, funcname: __init__
tds.py(4128):         self.columns = []
tds.py(4129):         self.row_count = 0
tds.py(2756):         header_tuple = []
tds.py(2757):         for col in range(num_cols):
tds.py(2758):             curcol = Column()
 --- modulename: tds, funcname: __init__
tds.py(4115):         self.char_codec = None
tds.py(4116):         self.column_name = name
tds.py(4117):         self.column_usertype = 0
tds.py(4118):         self.flags = flags
tds.py(4119):         self.type = type
tds.py(4120):         self.value = value
tds.py(2759):             info.columns.append(curcol)
tds.py(2760):             self.get_type_info(curcol)
 --- modulename: tds, funcname: get_type_info
tds.py(2711):         r = self._reader
tds.py(2713):         curcol.column_usertype = r.get_uint() if IS_TDS72_PLUS(self) else r.get_usmallint()
 --- modulename: tds, funcname: <lambda>
tds.py(38): IS_TDS72_PLUS = lambda x: x.tds_version >= TDS72
 --- modulename: tds, funcname: tds_version
tds.py(3071):         return self._tds.tds_version
 --- modulename: tds, funcname: get_uint
tds.py(773):         return self.unpack(_uint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2714):         curcol.flags = r.get_usmallint()  # Flags
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2715):         curcol.column_nullable = curcol.flags & Column.fNullable
tds.py(2716):         curcol.column_writeable = (curcol.flags & Column.fReadWrite) > 0
tds.py(2717):         curcol.column_identity = (curcol.flags & Column.fIdentity) > 0
tds.py(2718):         type_id = r.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2719):         type_class = self._tds._type_map.get(type_id)
tds.py(2720):         if not type_class:
tds.py(2722):         curcol.type = type_class.from_stream(r)
 --- modulename: tds, funcname: from_stream
tds.py(1441):         size = r.get_usmallint()
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(1442):         collation = r.get_collation()
 --- modulename: tds, funcname: get_collation
tds.py(803):         buf = readall(self, Collation.wire_size)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(804):         return Collation.unpack(buf)
 --- modulename: collate, funcname: unpack
collate.py(223):         lump, sort_id = cls._coll_struct.unpack_from(b)
collate.py(224):         lcid = lump & 0xfffff
collate.py(225):         ignore_case = bool(lump & cls.f_ignore_case)
collate.py(226):         ignore_accent = bool(lump & cls.f_ignore_accent)
collate.py(227):         ignore_width = bool(lump & cls.f_ignore_width)
collate.py(228):         ignore_kana = bool(lump & cls.f_ignore_kana)
collate.py(229):         binary = bool(lump & cls.f_binary)
collate.py(230):         binary2 = bool(lump & cls.f_binary2)
collate.py(231):         version = (lump & 0xf0000000) >> 26
collate.py(232):         return cls(lcid=lcid,
collate.py(233):                    ignore_case=ignore_case,
collate.py(234):                    ignore_accent=ignore_accent,
collate.py(235):                    ignore_width=ignore_width,
collate.py(236):                    ignore_kana=ignore_kana,
collate.py(237):                    binary=binary,
collate.py(238):                    binary2=binary2,
collate.py(239):                    version=version,
collate.py(240):                    sort_id=sort_id)
 --- modulename: collate, funcname: __init__
collate.py(199):         self.lcid = lcid
collate.py(200):         self.sort_id = sort_id
collate.py(201):         self.ignore_case = ignore_case
collate.py(202):         self.ignore_accent = ignore_accent
collate.py(203):         self.ignore_width = ignore_width
collate.py(204):         self.ignore_kana = ignore_kana
collate.py(205):         self.binary = binary
collate.py(206):         self.binary2 = binary2
collate.py(207):         self.version = version
tds.py(1443):         if size == 0xffff:
tds.py(1445):         return cls(size, collation)
 --- modulename: tds, funcname: __init__
tds.py(1424):         super(VarChar71, self).__init__(size, codec=collation.get_codec())
 --- modulename: collate, funcname: get_codec
collate.py(267):         return codecs.lookup(self.get_charset())
 --- modulename: collate, funcname: get_charset
collate.py(261):         if self.sort_id:
collate.py(262):             return sortid2charset(self.sort_id)
 --- modulename: collate, funcname: sortid2charset
collate.py(15):     sql_collate = sort_id
collate.py(20):     if sql_collate in (
collate.py(25):             34):  # SQL_Latin1_General_CP437_CI_AI
collate.py(27):     elif sql_collate in (
collate.py(40):             61):  # SQL_AltDiction_CP850_CI_AS
collate.py(42):     elif sql_collate in (
collate.py(59):             96,  # SQL_Slovenian_Cp1250_CI_AS_KI_WI
collate.py(62):     elif sql_collate in (
collate.py(67):             108,  # SQL_Ukrainian_Cp1251_CI_AS_KI_WI
collate.py(70):     elif sql_collate in (
collate.py(78):             186,  # SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
collate.py(80):         return 'CP1252'
 --- modulename: __init__, funcname: search_function
__init__.py(74):     entry = _cache.get(encoding, _unknown)
__init__.py(75):     if entry is not _unknown:
__init__.py(85):     norm_encoding = normalize_encoding(encoding)
 --- modulename: __init__, funcname: normalize_encoding
__init__.py(64):     if hasattr(__builtin__, "unicode") and isinstance(encoding, unicode):
__init__.py(69):     return '_'.join(encoding.translate(_norm_encoding_map).split())
__init__.py(86):     aliased_encoding = _aliases.get(norm_encoding) or \
__init__.py(87):                        _aliases.get(norm_encoding.replace('.', '_'))
__init__.py(88):     if aliased_encoding is not None:
__init__.py(92):         modnames = [norm_encoding]
__init__.py(93):     for modname in modnames:
__init__.py(94):         if not modname or '.' in modname:
__init__.py(96):         try:
__init__.py(99):             mod = __import__('encodings.' + modname, fromlist=_import_tail,
__init__.py(100):                              level=0)
 --- modulename: cp1252, funcname: <module>
cp1252.py(3): """#"
cp1252.py(5): import codecs
cp1252.py(9): class Codec(codecs.Codec):
 --- modulename: cp1252, funcname: Codec
cp1252.py(9): class Codec(codecs.Codec):
cp1252.py(11):     def encode(self,input,errors='strict'):
cp1252.py(14):     def decode(self,input,errors='strict'):
cp1252.py(17): class IncrementalEncoder(codecs.IncrementalEncoder):
 --- modulename: cp1252, funcname: IncrementalEncoder
cp1252.py(17): class IncrementalEncoder(codecs.IncrementalEncoder):
cp1252.py(18):     def encode(self, input, final=False):
cp1252.py(21): class IncrementalDecoder(codecs.IncrementalDecoder):
 --- modulename: cp1252, funcname: IncrementalDecoder
cp1252.py(21): class IncrementalDecoder(codecs.IncrementalDecoder):
cp1252.py(22):     def decode(self, input, final=False):
cp1252.py(25): class StreamWriter(Codec,codecs.StreamWriter):
 --- modulename: cp1252, funcname: StreamWriter
cp1252.py(25): class StreamWriter(Codec,codecs.StreamWriter):
cp1252.py(26):     pass
cp1252.py(28): class StreamReader(Codec,codecs.StreamReader):
 --- modulename: cp1252, funcname: StreamReader
cp1252.py(28): class StreamReader(Codec,codecs.StreamReader):
cp1252.py(29):     pass
cp1252.py(33): def getregentry():
cp1252.py(48):     u'\x00'     #  0x00 -> NULL
cp1252.py(307): encoding_table=codecs.charmap_build(decoding_table)
__init__.py(104):             break
__init__.py(108):     try:
__init__.py(109):         getregentry = mod.getregentry
__init__.py(114):     if mod is None:
__init__.py(120):     entry = getregentry()
 --- modulename: cp1252, funcname: getregentry
cp1252.py(34):     return codecs.CodecInfo(
cp1252.py(35):         name='cp1252',
cp1252.py(36):         encode=Codec().encode,
cp1252.py(37):         decode=Codec().decode,
cp1252.py(38):         incrementalencoder=IncrementalEncoder,
cp1252.py(39):         incrementaldecoder=IncrementalDecoder,
cp1252.py(40):         streamreader=StreamReader,
cp1252.py(41):         streamwriter=StreamWriter,
 --- modulename: codecs, funcname: __new__
codecs.py(79):         self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))
codecs.py(80):         self.name = name
codecs.py(81):         self.encode = encode
codecs.py(82):         self.decode = decode
codecs.py(83):         self.incrementalencoder = incrementalencoder
codecs.py(84):         self.incrementaldecoder = incrementaldecoder
codecs.py(85):         self.streamwriter = streamwriter
codecs.py(86):         self.streamreader = streamreader
codecs.py(87):         return self
__init__.py(121):     if not isinstance(entry, codecs.CodecInfo):
__init__.py(140):     _cache[encoding] = entry
__init__.py(144):     try:
__init__.py(145):         codecaliases = mod.getaliases()
__init__.py(146):     except AttributeError:
__init__.py(147):         pass
__init__.py(154):     return entry
 --- modulename: tds, funcname: __init__
tds.py(1390):         self._size = size
tds.py(1391):         self._codec = codec
tds.py(1425):         self._collation = collation
tds.py(2766):             curcol.column_name = r.read_ucs2(r.get_byte())
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
 --- modulename: tds, funcname: read_ucs2
tds.py(789):         buf = readall(self, num_chars * 2)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(790):         return ucs2_codec.decode(buf)[0]
 --- modulename: utf_16_le, funcname: decode
utf_16_le.py(16):     return codecs.utf_16_le_decode(input, errors, True)
tds.py(2767):             precision = curcol.type.precision if hasattr(curcol.type, 'precision') else None
tds.py(2768):             scale = curcol.type.scale if hasattr(curcol.type, 'scale') else None
tds.py(2769):             size = curcol.type._size if hasattr(curcol.type, '_size') else None
tds.py(2770):             header_tuple.append((curcol.column_name, curcol.type.get_typeid(), None, size, precision, scale, curcol.column_nullable))
 --- modulename: tds, funcname: get_typeid
tds.py(1039):         return self.type
tds.py(2757):         for col in range(num_cols):
tds.py(2758):             curcol = Column()
 --- modulename: tds, funcname: __init__
tds.py(4115):         self.char_codec = None
tds.py(4116):         self.column_name = name
tds.py(4117):         self.column_usertype = 0
tds.py(4118):         self.flags = flags
tds.py(4119):         self.type = type
tds.py(4120):         self.value = value
tds.py(2759):             info.columns.append(curcol)
tds.py(2760):             self.get_type_info(curcol)
 --- modulename: tds, funcname: get_type_info
tds.py(2711):         r = self._reader
tds.py(2713):         curcol.column_usertype = r.get_uint() if IS_TDS72_PLUS(self) else r.get_usmallint()
 --- modulename: tds, funcname: <lambda>
tds.py(38): IS_TDS72_PLUS = lambda x: x.tds_version >= TDS72
 --- modulename: tds, funcname: tds_version
tds.py(3071):         return self._tds.tds_version
 --- modulename: tds, funcname: get_uint
tds.py(773):         return self.unpack(_uint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2714):         curcol.flags = r.get_usmallint()  # Flags
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2715):         curcol.column_nullable = curcol.flags & Column.fNullable
tds.py(2716):         curcol.column_writeable = (curcol.flags & Column.fReadWrite) > 0
tds.py(2717):         curcol.column_identity = (curcol.flags & Column.fIdentity) > 0
tds.py(2718):         type_id = r.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2719):         type_class = self._tds._type_map.get(type_id)
tds.py(2720):         if not type_class:
tds.py(2722):         curcol.type = type_class.from_stream(r)
 --- modulename: tds, funcname: from_stream
tds.py(1193):         return cls()
tds.py(2766):             curcol.column_name = r.read_ucs2(r.get_byte())
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
 --- modulename: tds, funcname: read_ucs2
tds.py(789):         buf = readall(self, num_chars * 2)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(790):         return ucs2_codec.decode(buf)[0]
 --- modulename: utf_16_le, funcname: decode
utf_16_le.py(16):     return codecs.utf_16_le_decode(input, errors, True)
tds.py(2767):             precision = curcol.type.precision if hasattr(curcol.type, 'precision') else None
tds.py(2768):             scale = curcol.type.scale if hasattr(curcol.type, 'scale') else None
tds.py(2769):             size = curcol.type._size if hasattr(curcol.type, '_size') else None
tds.py(2770):             header_tuple.append((curcol.column_name, curcol.type.get_typeid(), None, size, precision, scale, curcol.column_nullable))
 --- modulename: tds, funcname: get_typeid
tds.py(1039):         return self.type
tds.py(2757):         for col in range(num_cols):
tds.py(2758):             curcol = Column()
 --- modulename: tds, funcname: __init__
tds.py(4115):         self.char_codec = None
tds.py(4116):         self.column_name = name
tds.py(4117):         self.column_usertype = 0
tds.py(4118):         self.flags = flags
tds.py(4119):         self.type = type
tds.py(4120):         self.value = value
tds.py(2759):             info.columns.append(curcol)
tds.py(2760):             self.get_type_info(curcol)
 --- modulename: tds, funcname: get_type_info
tds.py(2711):         r = self._reader
tds.py(2713):         curcol.column_usertype = r.get_uint() if IS_TDS72_PLUS(self) else r.get_usmallint()
 --- modulename: tds, funcname: <lambda>
tds.py(38): IS_TDS72_PLUS = lambda x: x.tds_version >= TDS72
 --- modulename: tds, funcname: tds_version
tds.py(3071):         return self._tds.tds_version
 --- modulename: tds, funcname: get_uint
tds.py(773):         return self.unpack(_uint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2714):         curcol.flags = r.get_usmallint()  # Flags
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2715):         curcol.column_nullable = curcol.flags & Column.fNullable
tds.py(2716):         curcol.column_writeable = (curcol.flags & Column.fReadWrite) > 0
tds.py(2717):         curcol.column_identity = (curcol.flags & Column.fIdentity) > 0
tds.py(2718):         type_id = r.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2719):         type_class = self._tds._type_map.get(type_id)
tds.py(2720):         if not type_class:
tds.py(2722):         curcol.type = type_class.from_stream(r)
 --- modulename: tds, funcname: from_stream
tds.py(1441):         size = r.get_usmallint()
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(1442):         collation = r.get_collation()
 --- modulename: tds, funcname: get_collation
tds.py(803):         buf = readall(self, Collation.wire_size)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(804):         return Collation.unpack(buf)
 --- modulename: collate, funcname: unpack
collate.py(223):         lump, sort_id = cls._coll_struct.unpack_from(b)
collate.py(224):         lcid = lump & 0xfffff
collate.py(225):         ignore_case = bool(lump & cls.f_ignore_case)
collate.py(226):         ignore_accent = bool(lump & cls.f_ignore_accent)
collate.py(227):         ignore_width = bool(lump & cls.f_ignore_width)
collate.py(228):         ignore_kana = bool(lump & cls.f_ignore_kana)
collate.py(229):         binary = bool(lump & cls.f_binary)
collate.py(230):         binary2 = bool(lump & cls.f_binary2)
collate.py(231):         version = (lump & 0xf0000000) >> 26
collate.py(232):         return cls(lcid=lcid,
collate.py(233):                    ignore_case=ignore_case,
collate.py(234):                    ignore_accent=ignore_accent,
collate.py(235):                    ignore_width=ignore_width,
collate.py(236):                    ignore_kana=ignore_kana,
collate.py(237):                    binary=binary,
collate.py(238):                    binary2=binary2,
collate.py(239):                    version=version,
collate.py(240):                    sort_id=sort_id)
 --- modulename: collate, funcname: __init__
collate.py(199):         self.lcid = lcid
collate.py(200):         self.sort_id = sort_id
collate.py(201):         self.ignore_case = ignore_case
collate.py(202):         self.ignore_accent = ignore_accent
collate.py(203):         self.ignore_width = ignore_width
collate.py(204):         self.ignore_kana = ignore_kana
collate.py(205):         self.binary = binary
collate.py(206):         self.binary2 = binary2
collate.py(207):         self.version = version
tds.py(1443):         if size == 0xffff:
tds.py(1445):         return cls(size, collation)
 --- modulename: tds, funcname: __init__
tds.py(1424):         super(VarChar71, self).__init__(size, codec=collation.get_codec())
 --- modulename: collate, funcname: get_codec
collate.py(267):         return codecs.lookup(self.get_charset())
 --- modulename: collate, funcname: get_charset
collate.py(261):         if self.sort_id:
collate.py(262):             return sortid2charset(self.sort_id)
 --- modulename: collate, funcname: sortid2charset
collate.py(15):     sql_collate = sort_id
collate.py(20):     if sql_collate in (
collate.py(25):             34):  # SQL_Latin1_General_CP437_CI_AI
collate.py(27):     elif sql_collate in (
collate.py(40):             61):  # SQL_AltDiction_CP850_CI_AS
collate.py(42):     elif sql_collate in (
collate.py(59):             96,  # SQL_Slovenian_Cp1250_CI_AS_KI_WI
collate.py(62):     elif sql_collate in (
collate.py(67):             108,  # SQL_Ukrainian_Cp1251_CI_AS_KI_WI
collate.py(70):     elif sql_collate in (
collate.py(78):             186,  # SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
collate.py(80):         return 'CP1252'
 --- modulename: tds, funcname: __init__
tds.py(1390):         self._size = size
tds.py(1391):         self._codec = codec
tds.py(1425):         self._collation = collation
tds.py(2766):             curcol.column_name = r.read_ucs2(r.get_byte())
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
 --- modulename: tds, funcname: read_ucs2
tds.py(789):         buf = readall(self, num_chars * 2)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(790):         return ucs2_codec.decode(buf)[0]
 --- modulename: utf_16_le, funcname: decode
utf_16_le.py(16):     return codecs.utf_16_le_decode(input, errors, True)
tds.py(2767):             precision = curcol.type.precision if hasattr(curcol.type, 'precision') else None
tds.py(2768):             scale = curcol.type.scale if hasattr(curcol.type, 'scale') else None
tds.py(2769):             size = curcol.type._size if hasattr(curcol.type, '_size') else None
tds.py(2770):             header_tuple.append((curcol.column_name, curcol.type.get_typeid(), None, size, precision, scale, curcol.column_nullable))
 --- modulename: tds, funcname: get_typeid
tds.py(1039):         return self.type
tds.py(2757):         for col in range(num_cols):
tds.py(2758):             curcol = Column()
 --- modulename: tds, funcname: __init__
tds.py(4115):         self.char_codec = None
tds.py(4116):         self.column_name = name
tds.py(4117):         self.column_usertype = 0
tds.py(4118):         self.flags = flags
tds.py(4119):         self.type = type
tds.py(4120):         self.value = value
tds.py(2759):             info.columns.append(curcol)
tds.py(2760):             self.get_type_info(curcol)
 --- modulename: tds, funcname: get_type_info
tds.py(2711):         r = self._reader
tds.py(2713):         curcol.column_usertype = r.get_uint() if IS_TDS72_PLUS(self) else r.get_usmallint()
 --- modulename: tds, funcname: <lambda>
tds.py(38): IS_TDS72_PLUS = lambda x: x.tds_version >= TDS72
 --- modulename: tds, funcname: tds_version
tds.py(3071):         return self._tds.tds_version
 --- modulename: tds, funcname: get_uint
tds.py(773):         return self.unpack(_uint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2714):         curcol.flags = r.get_usmallint()  # Flags
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2715):         curcol.column_nullable = curcol.flags & Column.fNullable
tds.py(2716):         curcol.column_writeable = (curcol.flags & Column.fReadWrite) > 0
tds.py(2717):         curcol.column_identity = (curcol.flags & Column.fIdentity) > 0
tds.py(2718):         type_id = r.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2719):         type_class = self._tds._type_map.get(type_id)
tds.py(2720):         if not type_class:
tds.py(2722):         curcol.type = type_class.from_stream(r)
 --- modulename: tds, funcname: from_stream
tds.py(1267):         size = r.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(1268):         if size not in cls._valid_sizes:
tds.py(1270):         return cls(size)
 --- modulename: tds, funcname: __init__
tds.py(1257):         assert size in self._valid_sizes
tds.py(1258):         self._size = size
tds.py(1259):         self._current_struct = self._struct[size]
tds.py(1260):         self._typeid = self._subtype[size].type
tds.py(2766):             curcol.column_name = r.read_ucs2(r.get_byte())
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
 --- modulename: tds, funcname: read_ucs2
tds.py(789):         buf = readall(self, num_chars * 2)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(790):         return ucs2_codec.decode(buf)[0]
 --- modulename: utf_16_le, funcname: decode
utf_16_le.py(16):     return codecs.utf_16_le_decode(input, errors, True)
tds.py(2767):             precision = curcol.type.precision if hasattr(curcol.type, 'precision') else None
tds.py(2768):             scale = curcol.type.scale if hasattr(curcol.type, 'scale') else None
tds.py(2769):             size = curcol.type._size if hasattr(curcol.type, '_size') else None
tds.py(2770):             header_tuple.append((curcol.column_name, curcol.type.get_typeid(), None, size, precision, scale, curcol.column_nullable))
 --- modulename: tds, funcname: get_typeid
tds.py(1263):         return self._typeid
tds.py(2757):         for col in range(num_cols):
tds.py(2758):             curcol = Column()
 --- modulename: tds, funcname: __init__
tds.py(4115):         self.char_codec = None
tds.py(4116):         self.column_name = name
tds.py(4117):         self.column_usertype = 0
tds.py(4118):         self.flags = flags
tds.py(4119):         self.type = type
tds.py(4120):         self.value = value
tds.py(2759):             info.columns.append(curcol)
tds.py(2760):             self.get_type_info(curcol)
 --- modulename: tds, funcname: get_type_info
tds.py(2711):         r = self._reader
tds.py(2713):         curcol.column_usertype = r.get_uint() if IS_TDS72_PLUS(self) else r.get_usmallint()
 --- modulename: tds, funcname: <lambda>
tds.py(38): IS_TDS72_PLUS = lambda x: x.tds_version >= TDS72
 --- modulename: tds, funcname: tds_version
tds.py(3071):         return self._tds.tds_version
 --- modulename: tds, funcname: get_uint
tds.py(773):         return self.unpack(_uint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2714):         curcol.flags = r.get_usmallint()  # Flags
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2715):         curcol.column_nullable = curcol.flags & Column.fNullable
tds.py(2716):         curcol.column_writeable = (curcol.flags & Column.fReadWrite) > 0
tds.py(2717):         curcol.column_identity = (curcol.flags & Column.fIdentity) > 0
tds.py(2718):         type_id = r.get_byte()
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(2719):         type_class = self._tds._type_map.get(type_id)
tds.py(2720):         if not type_class:
tds.py(2722):         curcol.type = type_class.from_stream(r)
 --- modulename: tds, funcname: from_stream
tds.py(1441):         size = r.get_usmallint()
 --- modulename: tds, funcname: get_usmallint
tds.py(765):         return self.unpack(_usmallint_le)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
tds.py(1442):         collation = r.get_collation()
 --- modulename: tds, funcname: get_collation
tds.py(803):         buf = readall(self, Collation.wire_size)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(804):         return Collation.unpack(buf)
 --- modulename: collate, funcname: unpack
collate.py(223):         lump, sort_id = cls._coll_struct.unpack_from(b)
collate.py(224):         lcid = lump & 0xfffff
collate.py(225):         ignore_case = bool(lump & cls.f_ignore_case)
collate.py(226):         ignore_accent = bool(lump & cls.f_ignore_accent)
collate.py(227):         ignore_width = bool(lump & cls.f_ignore_width)
collate.py(228):         ignore_kana = bool(lump & cls.f_ignore_kana)
collate.py(229):         binary = bool(lump & cls.f_binary)
collate.py(230):         binary2 = bool(lump & cls.f_binary2)
collate.py(231):         version = (lump & 0xf0000000) >> 26
collate.py(232):         return cls(lcid=lcid,
collate.py(233):                    ignore_case=ignore_case,
collate.py(234):                    ignore_accent=ignore_accent,
collate.py(235):                    ignore_width=ignore_width,
collate.py(236):                    ignore_kana=ignore_kana,
collate.py(237):                    binary=binary,
collate.py(238):                    binary2=binary2,
collate.py(239):                    version=version,
collate.py(240):                    sort_id=sort_id)
 --- modulename: collate, funcname: __init__
collate.py(199):         self.lcid = lcid
collate.py(200):         self.sort_id = sort_id
collate.py(201):         self.ignore_case = ignore_case
collate.py(202):         self.ignore_accent = ignore_accent
collate.py(203):         self.ignore_width = ignore_width
collate.py(204):         self.ignore_kana = ignore_kana
collate.py(205):         self.binary = binary
collate.py(206):         self.binary2 = binary2
collate.py(207):         self.version = version
tds.py(1443):         if size == 0xffff:
tds.py(1445):         return cls(size, collation)
 --- modulename: tds, funcname: __init__
tds.py(1424):         super(VarChar71, self).__init__(size, codec=collation.get_codec())
 --- modulename: collate, funcname: get_codec
collate.py(267):         return codecs.lookup(self.get_charset())
 --- modulename: collate, funcname: get_charset
collate.py(261):         if self.sort_id:
collate.py(262):             return sortid2charset(self.sort_id)
 --- modulename: collate, funcname: sortid2charset
collate.py(15):     sql_collate = sort_id
collate.py(20):     if sql_collate in (
collate.py(25):             34):  # SQL_Latin1_General_CP437_CI_AI
collate.py(27):     elif sql_collate in (
collate.py(40):             61):  # SQL_AltDiction_CP850_CI_AS
collate.py(42):     elif sql_collate in (
collate.py(59):             96,  # SQL_Slovenian_Cp1250_CI_AS_KI_WI
collate.py(62):     elif sql_collate in (
collate.py(67):             108,  # SQL_Ukrainian_Cp1251_CI_AS_KI_WI
collate.py(70):     elif sql_collate in (
collate.py(78):             186,  # SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
collate.py(80):         return 'CP1252'
 --- modulename: tds, funcname: __init__
tds.py(1390):         self._size = size
tds.py(1391):         self._codec = codec
tds.py(1425):         self._collation = collation
tds.py(2766):             curcol.column_name = r.read_ucs2(r.get_byte())
 --- modulename: tds, funcname: get_byte
tds.py(757):         return self.unpack(_byte)[0]
 --- modulename: tds, funcname: unpack
tds.py(752):         buf, offset = readall_fast(self, struct.size)
 --- modulename: tds, funcname: readall_fast
tds.py(686):     buf, offset = stm.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(687):     if len(buf) - offset < size:
tds.py(692):     return buf, offset
tds.py(753):         return struct.unpack_from(buf, offset)
 --- modulename: tds, funcname: read_ucs2
tds.py(789):         buf = readall(self, num_chars * 2)
 --- modulename: tds, funcname: readall
tds.py(682):     return b''.join(read_chunks(stm, size))
 --- modulename: tds, funcname: read_chunks
tds.py(651):     if size == 0:
tds.py(655):     res = stm.read(size)
 --- modulename: tds, funcname: read
tds.py(830):         buf, offset = self.read_fast(size)
 --- modulename: tds, funcname: read_fast
tds.py(735):         if self._pos >= len(self._buf):
tds.py(742):         offset = self._pos
tds.py(743):         self._pos += size
tds.py(744):         return self._buf, offset
tds.py(831):         return buf[offset:offset + size]
tds.py(656):     if len(res) == 0:
tds.py(658):     yield res
 --- modulename: tds, funcname: read_chunks
tds.py(659):     left = size - len(res)
tds.py(660):     while left:
tds.py(790):         return ucs2_codec.decode(buf)[0]
 --- modulename: utf_16_le, funcname: decode
utf_16_le.py(16):     return codecs.utf_16_le_decode(input, errors, True)
tds.py(2767):             precision = curcol.type.precision if hasattr(curcol.type, 'precision') else None
tds.py(2768):             scale = curcol.type.scale if hasattr(curcol.type, 'scale') else None
tds.py(2769):             size = curcol.type._size if hasattr(curcol.type, '_size') else None
tds.py(2770):             header_tuple.append((curcol.column_name, curcol.type.get_typeid(), None, size, precision, scale, curcol.column_nullable))
 --- modulename: tds, funcname: get_typeid
tds.py(1039):         return self.type
tds.py(2757):         for col in range(num_cols):
tds.py(2771):         info.description = tuple(header_tuple)
tds.py(2772):         return info
tds.py(3830):                 return True
['adrian@coinageandthingsco.com', '282', 'cmFpbmJvdw==', '2', 'NY']
['alejandra@angresellers.net', '237', 'aHVudGVy', '3', 'animal']
['alex@portoimportsco.net', '169', 'Y29tcHV0ZXI=', '2', 'Colorado']
['allen@collectablesforlessinc.net', '379', 'dmlwZXI=', '4', 'password']
['altagar@raananstores.net', '481', 'MTExMTEx', '2', 'California']
['annette@alphacognac.net', '242', 'Z2luZ2Vy', '3', 'cat']
['anton@antondesigns.net', '465', 'amFzcGVy', '4', 'asdf']
['arnold@cruzsonsco.net', '385', 'Zm9vYmFy', '3', 'animal']
['ashworth@avstores.net', '187', 'YWFhYWFh', '4', '123456']
['bertrand@lacornedabondance.com', '172', 'c2hhZG93', '3', 'cat']
['bill@australiancollectors.net', '114', 'bG92ZQ==', '4', 'coins']
['bob@ateliergraphique.com', '103', 'MTIzNDU2', '1', 'blue']
['bradley@schuylerimports.com', '303', 'Zmxvd2Vy', '4', 'openup']
['braun@preciouscollectables.com', '376', 'MXcyZTNl', '2', 'Colorado']
['brown@stylishdeskdecors.net', '324', 'cGFzc3cwcmQ=', '1', 'sky blue']
['calaghan@australiangoldnetwork.net', '333', 'ZnJpZW5kcw==', '4', '123456']
['cassidy@clovercollections.net', '189', 'c3VwZXJtYW4=', '3', 'cat']
['catherine@petitmetals.net', '314', 'Z29vZ2xl', '1', 'blue']
['cervantes@classicgoldideas.net', '339', 'c21va2V5', '3', 'dog']
['chandler@menrusretailers.com', '347', 'ZGlnaXRhbA==', '3', 'animal']
['clenahan@australiancollectables.net', '471', 'ZGFuaWVsbGU=', '3', 'dog']
['cramer@cramerspezialitten.com', '335', 'aGFybGV5', '4', 'coins']
['dan@goldideascorp.net', '447', 'Y29jYWNvbGE=', '1', 'blue']
['daniel@lyoncoinage.net', '250', 'YXBwbGU=', '1', 'green']
['daniel@metalsassociscie.com', '256', 'aWxvdmV5b3Uz', '3', 'dog']
['devon@ukcollectables.com', '201', 'Zm9vdGJhbGw=', '3', 'dog']
['donnermeyer@bavariancollectablesimports.net', '415', 'b25lbG92ZQ==', '3', 'animal']
['dopreciousque@metalscanalpetit.com', '406', 'ZGFsbGFz', '1', 'blue']
['dorothy@onlinepremiumcreationsco.net', '363', 'cG93ZXI=', '2', 'Texas']
['ed@bgecollectables.net', '293', 'Y29tcGFx', '1', 'blue']
['eduardo@enacodistributors.com', '216', 'c29jY2FyMQ==', '1', 'light blue']
['feuer@feueronlinestores.net', '443', 'YnViYmxlcw==', '1', 'sky blue']
['franco@fraudacollezione.com', '473', 'YW5nZWwx', '1', 'blue']
['franken@frankengold.net', '273', 'cm9ib3Q=', '3', 'dog']
['frdrique@preciouscaravy.net', '209', 'cGFzc3dvcmQx', '4', 'gold']
['gao@kingkongcollectables.net', '211', 'aWxvdmV5b3Ux', '1', 'sky blue']
['georg@salzburgcollectables.com', '382', 'Y3JlYXRpdmU=', '2', 'Florida']
['giovanni@rovelligold.com', '278', 'Z3VpdGFy', '4', 'coins']
['graham@downundercoinage.net', '323', 'YXVzdGlu', '2', 'Florida']
['hanna@mitvergngenco.com', '477', 'c2FtbXk=', '3', 'cat']
['helen@goldbymailcouk.net', '240', 'c25vb3B5', '2', 'Missouri']
['holz@vidasport.net', '298', 'Z29sZA==', '1', 'green']
['horst@natrlichmetals.com', '223', 'YmFzZWJhbGwx', '2', 'Ohio']
['james@landofcoinsinc.net', '131', 'aG9wZQ==', '2', 'NY']
['jane@volvomodelreplicas.net', '144', 'bW90aGVy', '2', 'Texas']
['jean@qubechomeshoppingnetwork.com', '233', 'b3Jhbmdl', '2', 'California']
['jeff@musclecoinsinc.net', '151', 'bGV0bWVpbg==', '4', 'asdf']
['jerry@cambridgecollectablesco.com', '173', 'aW50ZXJuZXQ=', '4', '123456']
['jerry@goatgoldstore.net', '112', 'cGFzc3dvcmQ=', '3', 'dog']
['jesus@cafimports.net', '344', 'bHVja3k=', '3', 'dog']
['jill@baanepreciousimports.net', '121', 'cHJpbmNlc3M=', '3', 'cat']
['julie@coins4grownupscom.com', '205', 'bWljaGFlbA==', '2', 'Texas']
['julie@corporategoldideasco.com', '321', 'YWRtaW4=', '4', 'qwerty']
['julie@golddepotinc.com', '175', 'd2hhdGV2ZXI=', '4', '123456']
['julie@preciousmetalsco.com', '129', 'c3VtbWVy', '2', 'Texas']
['juri@gold4allagescom.net', '362', 'aG9ja2V5', '4', 'asdf']
['kalle@suominencoinage.com', '334', 'bmludGVuZG8=', '2', 'New York']
['karin@kommissionmetals.net', '361', 'Y29ydmV0dGU=', '1', 'blue']
['karttunen@coinsoffinland.net', '186', 'bWF0cml4', '2', 'TX']
['kate@blauerseemetals.net', '128', 'aWxvdmV5b3U=', '2', 'Florida']
['keith@americanbankinc.com', '168', 'bW9ua2V5', '1', 'sky blue']
['kelvin@premiumclassicsinc.com', '157', 'dHJ1c3RubzE=', '4', '123456']
['klaeboe@norwaygoldbymail.net', '299', 'Y29vbA==', '2', 'New York']
['koskitalo@oulutoysupplies.net', '311', 'bWVybGlu', '2', 'Colorado']
['kuger@sardistributors.net', '356', 'ZW50ZXI=', '3', 'dog']
['laurence@marseillepreciousmetals.net', '350', 'c3Bpcml0', '3', 'dog']
['leslie@metalscoinclassicsinc.com', '198', 'cG9rZW1vbg==', '3', 'cat']
['leslie@supersilverinc.com', '455', 'YmFieQ==', '2', 'New York']
['lincoln@royalcanadiancollectables.net', '260', 'c2lsdmVy', '4', 'coins']
['maria@classiclegendsinc.com', '424', 'bWljcm9zb2Z0', '1', 'sky blue']
['mark@larochellegold.net', '119', 'MTIzNDU2Nzg=', '2', 'Ohio']
['marta@martasreplicasco.com', '286', 'ZGFrb3Rh', '1', 'red']
['martha@scandinaviangoldideas.com', '448', 'bG92aW5n', '3', 'animal']
['martine@daedalusdesignsimports.com', '171', 'YXNkZg==', '4', '123456']
['mary@boardscoinsco.com', '219', 'aWxvdmV5b3Uh', '2', 'NY']
['matt@euroshoppingchannel.net', '141', 'bG9va2luZw==', '1', 'light blue']
['maurizio@lordinecoinage.net', '386', 'c2xheWVy', '4', 'gold']
['mckenna@asiantreasures.net', '348', 'dGh1bmRlcg==', '2', 'New York']
['mcroy@extremedeskdecorations.com', '412', 'dGVzdHRlc3Q=', '3', 'dog']
['mel@derhundimports.net', '307', 'c2Nvb3Rlcg==', '4', '123456']
['michael@vitachromeinc.net', '181', 'cGFzcw==', '2', 'FL']
['miguel@onlinepreciouscollectables.net', '204', 'aGVscG1l', '2', 'Florida']
['mory@osakacoinageco.net', '177', 'Y2hlZXNl', '2', 'Texas']
['ohara@annasdecorations.com', '276', 'cGVhbnV0', '3', 'dog']
['palle@heintzecollectables.com', '227', 'cXdlcnR5MQ==', '4', 'password']
['paolo@amicacoinsco.com', '249', 'dGVzdGluZw==', '4', 'coins']
['pasilver@royalebelge.com', '381', 'cXdlcnR5MQ==', '1', 'blue']
['paul@reimscollectables.com', '353', 'YmFuZGl0', '1', 'blue']
['pfalzheim@tomsspezialitten.net', '259', 'Y2FuYWRh', '3', 'dog']
['renate@messnershoppingnetwork.com', '247', 'bXVzdGFuZw==', '2', 'California']
['rita@stuttgartcollectableexchange.com', '409', 'Z3JlZW4=', '1', 'red']
['rob@saveleyhenriot.net', '146', 'aGFwcHk=', '2', 'Florida']
['rodriguez@lisboacoinage.net', '369', 'YmVuamFtaW4=', '3', 'dog']
['roel@iberiagoldimports.com', '484', 'bGlnaHRuaW5n', '1', 'blue']
['roland@preciousmetalswerke.com', '452', 'bWF4d2VsbA==', '3', 'cat']
['rosa@coinrmintdistributorsinc.com', '486', 'cmVtZW1iZXI=', '3', 'cat']
['sally@danishwholesaleimports.com', '145', 'Zm9vdGJhbGw=', '2', 'NY']
['sam@technicsstoresinc.com', '161', 'YWJjMTIz', '2', 'New York']
['semenov@kremlincollectables.com', '480', 'bm9uZQ==', '3', 'animal']
['shimamura@tokyocollectables.com', '398', 'd2lzZG9t', '3', 'cat']
['sky@havelzbyszekco.com', '125', 'c2luZ2xl', '2', 'California']
['smith@doubledeckergoldstores.com', '489', 'bGV0bWVpbjE=', '3', 'dog']
['sommer@corridametalsreplicas.net', '458', 'ZGV4dGVy', '3', 'dog']
['steve@dragoncoinage.com', '148', 'cXdlcnR5', '3', 'cat']
['steve@preciousclassics.net', '319', 'c3RhcnRyZWs=', '2', 'Colorado']
['steve@westcoastcollectablesco.net', '475', 'NTU1NTU1', '4', 'letmein']
['sue@signalcollectiblesltd.net', '487', 'b3BlbnVw', '2', 'California']
['sue@thesharpgoldwarehouse.net', '450', 'cGFzc3dvcmQh', '3', 'cat']
['susan@preciousgolddistributorsltd.com', '124', 'c3Vuc2hpbmU=', '2', 'California']
['sven@warburgexchange.com', '459', 'a2l0dGVu', '1', 'light blue']
['tony@kellysgoldshop.net', '496', 'c3RhcndhcnM=', '1', 'sky blue']
['valarie@collectablepreciousdesignsco.com', '239', 'amVubmlmZXI=', '4', 'coins']
['valarie@premiumcollectables.com', '495', 'bHVja3kx', '1', 'blue']
['vey@herkkugold.net', '167', 'ZHJhZ29u', '1', 'blue']
['violeta@fungoldideascom.com', '462', 'c3RlbGxh', '3', 'dog']
['wales@goldforhimcom.net', '357', 'YW50aG9ueQ==', '4', 'openup']
['walker@asianshoppingnetwork.com', '206', 'c2VjcmV0', '3', 'dog']
['wendy@handjigoldco.com', '166', 'aGVsbG8=', '1', 'sky blue']
['william@teknicollectablesinc.net', '328', 'd2lubmVy', '1', 'red']
['wing@preciouscreationsltd.net', '320', 'bWF0cml4IQ==', '4', 'password']
['yoshi@canadiangoldexchangenetwork.com', '202', 'YmxhaGJsYWg=', '4', 'letmein']
['yu@microsilverinc.com', '456', 'cHJpbmNl', '2', 'New York']
